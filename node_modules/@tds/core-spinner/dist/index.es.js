import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { position } from '@tds/shared-styles';
import { media } from '@tds/core-responsive';
import { uniqueId, safeRest } from '@tds/util-helpers';
import { colorAccessibleGreen, colorSecondary } from '@tds/core-colours';
import Text from '@tds/core-text';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var assertThisInitialized = _assertThisInitialized;

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

var possibleConstructorReturn = _possibleConstructorReturn;

var getPrototypeOf = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
});

var setPrototypeOf = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
});

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

var inherits = _inherits;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

/* eslint-disable import/prefer-default-export */
var deprecate = function deprecate(componentName, message) {
  if (process.env.NODE_ENV === 'production') {
    return;
  }

  console.warn("[TDS] [Deprecate] ".concat(componentName, ": ").concat(message)); // eslint-disable-line no-console
};
var warn = function warn(componentName, message) {
  if (process.env.NODE_ENV === 'production') {
    return;
  }

  console.warn("[TDS] ".concat(componentName, ": ").concat(message)); // eslint-disable-line no-console
};

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var taggedTemplateLiteral = _taggedTemplateLiteral;

function _templateObject2() {
  var data = taggedTemplateLiteral(["\n  0% {\n      stroke-dasharray: 1, 200;\n      stroke-dashoffset: 0;\n    }\n\n    50% {\n      stroke-dasharray: 89, 200;\n      stroke-dashoffset: -35;\n    }\n\n    100% {\n      stroke-dasharray: 89, 200;\n      stroke-dashoffset: -124;\n    }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = taggedTemplateLiteral(["\n  100% {\n    transform: rotate(360deg);\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var keyframes = require('styled-components').keyframes;

var zindexPopover = 1600;
var spinnerRotate = keyframes(_templateObject());
var spinnerDash = keyframes(_templateObject2());
var SvgContainer = styled.div.withConfig({
  displayName: "SpinnerSvg__SvgContainer",
  componentId: "sc-6yts5w-0"
})(function (_ref) {
  var overlay = _ref.overlay;
  return _extends_1({
    display: 'inline-flex',
    flexDirection: 'column',
    alignItems: 'center'
  }, overlay && {
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    zIndex: zindexPopover
  });
});
var StyledSvg = styled.svg.withConfig({
  displayName: "SpinnerSvg__StyledSvg",
  componentId: "sc-6yts5w-1"
})(["animation:", " 1.8s linear infinite;", " ", ""], spinnerRotate, function (_ref2) {
  var size = _ref2.size;
  return size === 'small' && 'height: 3.125rem; width: 3.125rem;';
}, function (_ref3) {
  var size = _ref3.size;
  return size === 'large' && 'height: 6.25rem; width: 6.25rem;';
});
var SvgCircle = styled.circle.withConfig({
  displayName: "SpinnerSvg__SvgCircle",
  componentId: "sc-6yts5w-2"
})(["animation:", " 1.7s ease-in-out infinite 0s;", " ", ""], spinnerDash, function (_ref4) {
  var variant = _ref4.variant;
  return variant === 'primary' && "stroke: ".concat(colorAccessibleGreen);
}, function (_ref5) {
  var variant = _ref5.variant;
  return variant === 'secondary' && "stroke: ".concat(colorSecondary);
});
var TipContainer = styled.div.withConfig({
  displayName: "SpinnerSvg__TipContainer",
  componentId: "sc-6yts5w-3"
})({
  marginTop: '-1.5rem'
});

var SpinnerSvg = function SpinnerSvg(_ref6) {
  var tip = _ref6.tip,
      overlay = _ref6.overlay,
      a11yLabel = _ref6.a11yLabel,
      size = _ref6.size,
      variant = _ref6.variant,
      labelRef = _ref6.labelRef,
      rest = objectWithoutProperties(_ref6, ["tip", "overlay", "a11yLabel", "size", "variant", "labelRef"]);

  var titleId = uniqueId('spinner-title-');
  return React.createElement(SvgContainer, {
    overlay: overlay,
    "data-testid": "spinner"
  }, React.createElement(StyledSvg, _extends_1({}, safeRest(rest), {
    viewBox: "0 0 100 100",
    width: size === 'large' ? '100' : '50',
    height: size === 'large' ? '100' : '50',
    role: "alert",
    "aria-labelledby": titleId,
    "aria-live": "assertive",
    "data-testid": "svg"
  }), React.createElement("title", {
    id: titleId
  }, a11yLabel), React.createElement(SvgCircle, {
    variant: size === 'small' ? variant : 'primary',
    strokeWidth: "4",
    fill: "none",
    strokeLinecap: "round",
    strokeDasharray: "89, 200",
    strokeDashoffset: "0",
    cx: "50",
    cy: "50",
    r: "20"
  })), tip && React.createElement(TipContainer, {
    tabIndex: "-1",
    ref: labelRef
  }, React.createElement(Text, {
    size: "small"
  }, tip)));
};

SpinnerSvg.propTypes = {
  tip: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  overlay: PropTypes.bool,
  a11yLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.node]).isRequired,
  size: PropTypes.oneOf(['large', 'small']).isRequired,
  variant: PropTypes.oneOf(['primary', 'secondary']).isRequired,
  labelRef: PropTypes.object
};
SpinnerSvg.defaultProps = {
  tip: undefined,
  overlay: false,
  labelRef: undefined
};

var zindexModalBackdrop = 1400;
var SpinnerContainer = styled.div.withConfig({
  displayName: "Spinner__SpinnerContainer",
  componentId: "sc-12sh5b7-0"
})(function (_ref) {
  var inline = _ref.inline,
      fullScreen = _ref.fullScreen;
  return _extends_1({}, position.relative, {}, inline && _extends_1({
    display: 'block'
  }, media.from('md').css({
    display: 'inline-block'
  })), {}, fullScreen && position.centerVertically);
});
var ContentOverlay = styled.div.withConfig({
  displayName: "Spinner__ContentOverlay",
  componentId: "sc-12sh5b7-1"
})({
  position: 'absolute',
  width: '100%',
  height: '100%',
  zIndex: zindexModalBackdrop
});
var FullscreenOverlay = styled.div.withConfig({
  displayName: "Spinner__FullscreenOverlay",
  componentId: "sc-12sh5b7-2"
})({
  position: 'fixed',
  width: '100vw',
  height: '100vh',
  top: 0,
  left: 0,
  zIndex: zindexModalBackdrop,
  backgroundColor: 'rgba(255, 255, 255, 0.96)'
});
var OpaqueContainer = styled.div.withConfig({
  displayName: "Spinner__OpaqueContainer",
  componentId: "sc-12sh5b7-3"
})({
  opacity: 0.06
});

var recursiveMap = function recursiveMap(children, fn) {
  return React.Children.map(children, function (child) {
    if (!React.isValidElement(child)) {
      return child;
    }

    if (child.props.children) {
      return fn(React.cloneElement(child, {
        children: recursiveMap(child.props.children, fn)
      }));
    }

    return fn(child);
  });
};
/**
 * A waiting indicator.
 *
 * @version ./package.json
 */


var Spinner =
/*#__PURE__*/
function (_React$PureComponent) {
  inherits(Spinner, _React$PureComponent);

  function Spinner() {
    var _this;

    classCallCheck(this, Spinner);

    _this = possibleConstructorReturn(this, getPrototypeOf(Spinner).call(this));

    defineProperty(assertThisInitialized(_this), "preventScroll", function (e) {
      if (_this.spinnerOverlayRef.current.contains(e.targetTouches[0].target)) {
        e.preventDefault();
      }
    });

    _this.spinnerOverlayRef = null;
    return _this;
  }

  createClass(Spinner, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.props.fullScreen && this.props.spinning) {
        document.body.addEventListener('touchmove', this.preventScroll, {
          passive: false
        });
        document.body.addEventListener('touchstart', this.preventScroll, {
          passive: false
        });
        document.body.style.overflow = 'hidden';
      } else {
        document.body.removeEventListener('touchmove', this.preventScroll);
        document.body.removeEventListener('touchstart', this.preventScroll);
        document.body.style.overflow = 'auto';
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          spinning = _this$props.spinning,
          label = _this$props.label,
          dangerouslyHideVisibleLabel = _this$props.dangerouslyHideVisibleLabel,
          tip = _this$props.tip,
          a11yLabel = _this$props.a11yLabel,
          inline = _this$props.inline,
          size = _this$props.size,
          variant = _this$props.variant,
          fullScreen = _this$props.fullScreen,
          labelRef = _this$props.labelRef,
          children = _this$props.children,
          rest = objectWithoutProperties(_this$props, ["spinning", "label", "dangerouslyHideVisibleLabel", "tip", "a11yLabel", "inline", "size", "variant", "fullScreen", "labelRef", "children"]);

      if (tip) {
        deprecate('core-spinner', 'The `tip` prop is deprecated. Please use the `label` prop.');
      }

      if (a11yLabel && label === undefined) {
        deprecate('core-spinner', 'The `a11yLabel` prop is deprecated. Please use the `label` prop.');
      }

      if (size === 'large' && variant === 'secondary') {
        warn('core-spinner', 'The Spinner should not use the `secondary` variant while `size` is set to `large`.');
      }

      if (!spinning) {
        return children || null;
      }

      var spinnerSvg = function spinnerSvg(props) {
        return React.createElement(SpinnerSvg, _extends_1({}, props, safeRest(rest), {
          tip: dangerouslyHideVisibleLabel || size === 'small' ? undefined : label || tip,
          a11yLabel: label || a11yLabel,
          size: size,
          variant: variant,
          labelRef: labelRef
        }));
      };

      if (fullScreen) {
        return React.createElement(FullscreenOverlay, {
          ref: function ref(el) {
            _this2.spinnerOverlayRef = el;
          },
          "data-testid": "overlay"
        }, React.createElement(SpinnerContainer, {
          inline: inline,
          fullScreen: fullScreen,
          "data-testid": "container",
          "aria-live": "assertive"
        }, spinnerSvg({
          overlay: true
        })));
      }

      if (children) {
        return React.createElement(SpinnerContainer, {
          inline: inline,
          fullScreen: fullScreen,
          "data-testid": "container",
          "aria-live": "assertive"
        }, spinnerSvg({
          overlay: true
        }), React.createElement(ContentOverlay, {
          "data-testid": "overlay"
        }), React.createElement(OpaqueContainer, {
          inert: "true"
        }, recursiveMap(children, function (c) {
          if (c) {
            return React.cloneElement(c, {
              tabIndex: '-1',
              'aria-hidden': 'true'
            });
          }

          return undefined;
        })));
      }

      return spinnerSvg();
    }
  }]);

  return Spinner;
}(React.PureComponent);

Spinner.propTypes = {
  /**
   * Whether or not to render the spinner.
   */
  spinning: PropTypes.bool,

  /**
   * Communicates a message to assistive technology while visible. This same message will appear underneath the spinner when its `size` is `large`.
   *
   * When used with `A11yContent`, label text should be wrapped by a `<span>` or `<React.Fragment>`.
   *
   * @since 2.2.0
   */
  label: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),

  /**
   * Hides the visible label under the spinner when the spinner's `size` is set to `large`. For special circumstances only.
   * @ignore
   */
  dangerouslyHideVisibleLabel: PropTypes.bool,

  /**
   * A additional displayed message.
   * @deprecated This prop and `a11yLabel` have been combined into the `label` prop.
   */
  tip: PropTypes.string,

  /**
   * A label for assistive technology.
   * @deprecated This prop and `tip` have been combined into the `label` prop.
   */
  a11yLabel: PropTypes.string,

  /**
   * Render the Spinner as inline-block. This can be used when wrapping
   * interactive elements such as buttons.
   *
   * @since 2.1.0
   */
  inline: PropTypes.bool,

  /**
   * The size of the spinner
   *
   * @since 2.2.0
   */
  size: PropTypes.oneOf(['large', 'small']),

  /**
   * The spinner's colour. The `secondary` variant is only available when `size` is set to `small`.
   *
   * @since 2.2.0
   */
  variant: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * Enables body locking
   *
   * @since 2.2.0
   */
  fullScreen: PropTypes.bool,

  /**
   * Content to be overlaid while the spinner is active. Can be text, any HTML element,
   * or any component.
   */
  children: PropTypes.node,

  /**
   * A React ref to the label on the `Spinner`, can be used to set initial focus.
   *
   * @since 3.0.5
   */
  labelRef: PropTypes.object
};
Spinner.defaultProps = {
  spinning: false,
  label: undefined,
  dangerouslyHideVisibleLabel: false,
  tip: undefined,
  a11yLabel: 'A spinner is active. Please wait while the page completes a task.',
  inline: false,
  size: 'large',
  variant: 'primary',
  fullScreen: false,
  children: undefined,
  labelRef: undefined
};

export default Spinner;
