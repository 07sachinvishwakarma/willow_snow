import React, { useRef, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import FlexGrid from '@tds/core-flex-grid';
import { safeRest } from '@tds/util-helpers';
import { ChevronLeft, ChevronRight } from '@tds/core-interactive-icon';
import { Tabs as Tabs$1, TabList, Tab, TabPanel } from 'react-tabs';
import styled, { css } from 'styled-components';
import { colorGreyGainsboro, colorGreyShark as colorGreyShark$1, colorWhite, colorGreyRaven } from '@tds/core-colours';
import stringHash from 'string-hash';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function createCommonjsModule$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1$1 = createCommonjsModule$1(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

var colorGreyShark = '#2a2c2e';
var colorText = colorGreyShark; // tokens

var fontTelus = '"TELUS-Web", "Helvetica Neue", Helvetica, Arial, sans-serif';
var helveticaNeueLight45 = {
  fontWeight: 400
};
var helveticaNeueRoman55 = {
  fontWeight: 500
};
var helveticaNeueMedium65 = {
  fontWeight: 700
};
var sizeSmall = {
  fontSize: '0.875rem',
  letterSpacing: -0.6,
  lineHeight: '1.42857'
};
var sizeMedium = {
  fontSize: '1rem',
  letterSpacing: -0.8,
  lineHeight: '1.5'
};
var sizeLarge = {
  fontSize: '1.25rem',
  letterSpacing: -1,
  lineHeight: '1.6'
};
var wordBreak = {
  wordWrap: 'break-word'
};
var baseSupSubScripts = {
  position: 'relative',
  verticalAlign: 'baseline',
  paddingLeft: '0.1em'
};
var sup = _extends_1$1({
  top: '-0.5em',
  fontSize: '0.875rem'
}, baseSupSubScripts);
var base = _extends_1$1({}, wordBreak, {
  fontSize: 'inherit'
});
var small = _extends_1$1({}, wordBreak, sizeSmall);
var smallFont = _extends_1$1({}, helveticaNeueRoman55);
var medium = _extends_1$1({}, wordBreak, sizeMedium);
var mediumFont = _extends_1$1({}, helveticaNeueLight45);
var large = _extends_1$1({}, wordBreak, sizeLarge);
var largeFont = _extends_1$1({}, wordBreak, helveticaNeueLight45);
var boldFont = _extends_1$1({}, wordBreak, helveticaNeueMedium65);
var color = {
  color: colorText
};

var thin = {
  borderWidth: 1,
  borderStyle: 'solid'
};
var none = {
  borderWidth: '0'
};
var rounded = {
  borderRadius: '4px'
};
var circular = {
  borderRadius: '50%'
};

var borders = /*#__PURE__*/Object.freeze({
  thin: thin,
  none: none,
  rounded: rounded,
  circular: circular
});

/* eslint-disable import/prefer-default-export */
var noSpacing = {
  padding: 0,
  margin: 0
};

var spacing = /*#__PURE__*/Object.freeze({
  noSpacing: noSpacing
});
var font = {
  fontFamily: fontTelus
};

function createCommonjsModule$2(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1$2 = createCommonjsModule$2(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

/* eslint-disable import/prefer-default-export */
var base$1 = {
  '&': {
    paddingLeft: '3rem'
  },
  '& &': {
    marginTop: '1rem',
    marginBottom: '0.5rem'
  }
};
var nestedListSpacing = _extends_1$2({}, base$1, {
  '& :last-child &': {
    marginBottom: 0
  }
});

/* eslint-disable import/prefer-default-export */

var noStyle = _extends_1$2({}, noSpacing, none, font, color, {
  appearance: 'none',
  background: 'none',
  boxShadow: 'none',
  cursor: 'pointer'
});

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose$1 = _objectWithoutPropertiesLoose$1;

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties$1 = _objectWithoutProperties$1;

function createCommonjsModule$3(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1$3 = createCommonjsModule$3(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

var baseStyle = {
  transform: 'rotate(-0.00001deg)',
  flexShrink: 0
};

var horizontalStyle = _extends_1$3({}, baseStyle, {
  width: '100%',
  height: '1px'
});

var verticalStyle = _extends_1$3({}, baseStyle, {
  display: 'inline-block',
  width: '1px'
});

var StyledHairlineDivider = styled.hr.withConfig({
  displayName: "HairlineDivider__StyledHairlineDivider",
  componentId: "biamlk-0"
})(spacing.noSpacing, borders.none, function (props) {
  if (props.vertical && props.gradient) {
    return _extends_1$3({}, verticalStyle, {
      'background-image': "\n        linear-gradient(0deg, rgba(216, 216, 216, 0) 0%,\n        ".concat(colorGreyGainsboro, " 12%,\n        ").concat(colorGreyGainsboro, " 88%,\n        rgba(216, 216, 216, 0) 100%)\n      ")
    });
  }

  if (props.vertical && !props.gradient) {
    return _extends_1$3({}, verticalStyle, {
      'background-color': colorGreyGainsboro
    });
  }

  if (!props.vertical && props.gradient) {
    return _extends_1$3({}, horizontalStyle, {
      'background-image': "\n        linear-gradient(90deg, rgba(216, 216, 216, 0) 0%,\n        ".concat(colorGreyGainsboro, " 7%,\n        ").concat(colorGreyGainsboro, " 93%,\n        rgba(216, 216, 216, 0) 100%)\n      ")
    });
  }

  return _extends_1$3({}, horizontalStyle, {
    'background-color': colorGreyGainsboro
  });
});
/**
 * Separate content within modules.
 *
 * @version ./package.json
 */

var HairlineDivider = function HairlineDivider(_ref) {
  var vertical = _ref.vertical,
      gradient = _ref.gradient,
      rest = objectWithoutProperties$1(_ref, ["vertical", "gradient"]);

  return React.createElement(StyledHairlineDivider, _extends_1$3({}, safeRest(rest), {
    vertical: vertical,
    gradient: gradient
  }));
};

HairlineDivider.propTypes = {
  /**
   * Draw the divider vertically.
   */
  vertical: PropTypes.bool,

  /**
   * Use a subtle gradient instead of a solid thin line.
   */
  gradient: PropTypes.bool
};
HairlineDivider.defaultProps = {
  vertical: false,
  gradient: false
};

function createCommonjsModule$4(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1$4 = createCommonjsModule$4(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose$2 = _objectWithoutPropertiesLoose$2;

function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties$2 = _objectWithoutProperties$2;

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var browser = invariant;

var camel2hyphen = function (str) {
  return str
          .replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
          })
          .toLowerCase();
};

var camel2hyphen_1 = camel2hyphen;

var isDimension = function (feature) {
  var re = /[height|width]$/;
  return re.test(feature);
};

var obj2mq = function (obj) {
  var mq = '';
  var features = Object.keys(obj);
  features.forEach(function (feature, index) {
    var value = obj[feature];
    feature = camel2hyphen_1(feature);
    // Add px to dimension features
    if (isDimension(feature) && typeof value === 'number') {
      value = value + 'px';
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += 'not ' + feature;
    } else {
      mq += '(' + feature + ': ' + value + ')';
    }
    if (index < features.length-1) {
      mq += ' and ';
    }
  });
  return mq;
};

var json2mq = function (query) {
  var mq = '';
  if (typeof query === 'string') {
    return query;
  }
  // Handling array of media queries
  if (query instanceof Array) {
    query.forEach(function (q, index) {
      mq += obj2mq(q);
      if (index < query.length-1) {
        mq += ', ';
      }
    });
    return mq;
  }
  // Handling single media query
  return obj2mq(query);
};

var json2mq_1 = json2mq;

var MediaQueryListener =
/*#__PURE__*/
function () {
  function MediaQueryListener(targetWindow, query, listener) {
    var _this = this;

    this.nativeMediaQueryList = targetWindow.matchMedia(query);
    this.active = true; // Safari doesn't clear up listener with removeListener
    // when the listener is already waiting in the event queue.
    // Having an active flag to make sure the listener is not called
    // after we removeListener.

    this.cancellableListener = function () {
      _this.matches = _this.nativeMediaQueryList.matches;

      if (_this.active) {
        listener.apply(void 0, arguments);
      }
    };

    this.nativeMediaQueryList.addListener(this.cancellableListener);
    this.matches = this.nativeMediaQueryList.matches;
  }

  var _proto = MediaQueryListener.prototype;

  _proto.cancel = function cancel() {
    this.active = false;
    this.nativeMediaQueryList.removeListener(this.cancellableListener);
  };

  return MediaQueryListener;
}();

var queryType = PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.arrayOf(PropTypes.object.isRequired)]);
/**
 * Conditionally renders based on whether or not a media query matches.
 */

var Media =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Media, _React$Component);

  function Media(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "queries", []);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getMatches", function () {
      var result = _this.queries.reduce(function (acc, _ref) {
        var _extends2;

        var name = _ref.name,
            mqListener = _ref.mqListener;
        return _extends({}, acc, (_extends2 = {}, _extends2[name] = mqListener.matches, _extends2));
      }, {}); // return result;


      return unwrapSingleQuery(result);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateMatches", function () {
      var newMatches = _this.getMatches();

      _this.setState(function () {
        return {
          matches: newMatches
        };
      }, _this.onChange);
    });

    !(!(!props.query && !props.queries) || props.query && props.queries) ? process.env.NODE_ENV !== "production" ? browser(false, '<Media> must be supplied with either "query" or "queries"') : browser(false) : void 0;
    !(props.defaultMatches === undefined || !props.query || typeof props.defaultMatches === "boolean") ? process.env.NODE_ENV !== "production" ? browser(false, "<Media> when query is set, defaultMatches must be a boolean, received " + typeof props.defaultMatches) : browser(false) : void 0;
    !(props.defaultMatches === undefined || !props.queries || typeof props.defaultMatches === "object") ? process.env.NODE_ENV !== "production" ? browser(false, "<Media> when queries is set, defaultMatches must be a object of booleans, received " + typeof props.defaultMatches) : browser(false) : void 0;

    if (typeof window !== "object") {
      // In case we're rendering on the server, apply the default matches
      var matches;

      if (props.defaultMatches !== undefined) {
        matches = props.defaultMatches;
      } else if (props.query) {
        matches = true;
      }
      /* if (props.queries) */
      else {
          matches = Object.keys(_this.props.queries).reduce(function (acc, key) {
            var _extends3;

            return _extends({}, acc, (_extends3 = {}, _extends3[key] = true, _extends3));
          }, {});
        }

      _this.state = {
        matches: matches
      };
      return _assertThisInitialized(_this);
    }

    _this.initialize(); // Instead of calling this.updateMatches, we manually set the initial state to prevent
    // calling setState, which could trigger an unnecessary second render


    _this.state = {
      matches: _this.props.defaultMatches !== undefined ? _this.props.defaultMatches : _this.getMatches()
    };

    _this.onChange();

    return _this;
  }

  var _proto = Media.prototype;

  _proto.initialize = function initialize() {
    var _this2 = this;

    var targetWindow = this.props.targetWindow || window;
    !(typeof targetWindow.matchMedia === "function") ? process.env.NODE_ENV !== "production" ? browser(false, "<Media targetWindow> does not support `matchMedia`.") : browser(false) : void 0;
    var queries = this.props.queries || wrapInQueryObject(this.props.query);
    this.queries = Object.keys(queries).map(function (name) {
      var query = queries[name];
      var qs = typeof query !== "string" ? json2mq_1(query) : query;
      var mqListener = new MediaQueryListener(targetWindow, qs, _this2.updateMatches);
      return {
        name: name,
        mqListener: mqListener
      };
    });
  };

  _proto.componentDidMount = function componentDidMount() {
    this.initialize(); // If props.defaultMatches has been set, ensure we trigger a two-pass render.
    // This is useful for SSR with mismatching defaultMatches vs actual matches from window.matchMedia
    // Details: https://github.com/ReactTraining/react-media/issues/81

    if (this.props.defaultMatches !== undefined) {
      this.updateMatches();
    }
  };

  _proto.onChange = function onChange() {
    var onChange = this.props.onChange;

    if (onChange) {
      onChange(this.state.matches);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.queries.forEach(function (_ref2) {
      var mqListener = _ref2.mqListener;
      return mqListener.cancel();
    });
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        render = _this$props.render;
    var matches = this.state.matches;
    var isAnyMatches = typeof matches === "object" ? Object.keys(matches).some(function (key) {
      return matches[key];
    }) : matches;
    return render ? isAnyMatches ? render(matches) : null : children ? typeof children === "function" ? children(matches) : !Array.isArray(children) || children.length // Preact defaults to empty children array
    ? isAnyMatches ? // We have to check whether child is a composite component or not to decide should we
    // provide `matches` as a prop or not
    React.Children.only(children) && typeof React.Children.only(children).type === "string" ? React.Children.only(children) : React.cloneElement(React.Children.only(children), {
      matches: matches
    }) : null : null : null;
  };

  return Media;
}(React.Component);
/**
 * Wraps a single query in an object. This is used to provide backward compatibility with
 * the old `query` prop (as opposed to `queries`). If only a single query is passed, the object
 * will be unpacked down the line, but this allows our internals to assume an object of queries
 * at all times.
 */


_defineProperty(Media, "propTypes", {
  defaultMatches: PropTypes.oneOfType([PropTypes.bool, PropTypes.objectOf(PropTypes.bool)]),
  query: queryType,
  queries: PropTypes.objectOf(queryType),
  render: PropTypes.func,
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  targetWindow: PropTypes.object,
  onChange: PropTypes.func
});

function wrapInQueryObject(query) {
  return {
    __DEFAULT__: query
  };
}
/**
 * Unwraps an object of queries, if it was originally passed as a single query.
 */


function unwrapSingleQuery(queryObject) {
  var queryNames = Object.keys(queryObject);

  if (queryNames.length === 1 && queryNames[0] === "__DEFAULT__") {
    return queryObject.__DEFAULT__;
  }

  return queryObject;
}

/* eslint-disable import/prefer-default-export */
var warn = function warn(componentName, message) {
  if (process.env.NODE_ENV === 'production') {
    return;
  }

  console.warn("[TDS] ".concat(componentName, ": ").concat(message)); // eslint-disable-line no-console
};

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty$1;

var breakpoints = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
var media = {
  query: {},
  from: function from(breakpoint) {
    if (breakpoint !== 'xs') {
      this.query.minWidth = breakpoint;
    }

    return this;
  },
  until: function until(breakpoint) {
    this.query.maxWidth = breakpoint;
    return this;
  },
  and: function and(custom) {
    this.query.and = custom;
    return this;
  },
  css: function css(style) {
    var _this$query = this.query,
        minWidth = _this$query.minWidth,
        maxWidth = _this$query.maxWidth,
        and = _this$query.and;
    var min = minWidth ? "(min-width: ".concat(breakpoints[minWidth], "px)") : undefined;
    var max = maxWidth ? "(max-width: ".concat(breakpoints[maxWidth] - 1, "px)") : undefined;

    if (typeof min !== 'undefined' || typeof max !== 'undefined' || typeof and !== 'undefined') {
      var mediaQuery = "@media ".concat([min, max, and].filter(function (a) {
        return a;
      }).join(' and '));
      this.query = {};
      return defineProperty({}, mediaQuery, _extends_1$4({}, typeof style === 'function' ? style() : style));
    }

    return typeof style === 'function' ? style() : style;
  }
};

/**
 * Respond to device features, most commonly the browser viewport size.
 *
 * @version ./package.json
 */

var Responsive = function Responsive(_ref) {
  var minWidth = _ref.minWidth,
      maxWidth = _ref.maxWidth,
      query = _ref.query,
      children = _ref.children,
      rest = objectWithoutProperties$2(_ref, ["minWidth", "maxWidth", "query", "children"]);

  if (!minWidth && !maxWidth) {
    warn('Responsive', 'Responsive needs a minWidth or maxWith prop');
  } // Do it this way to not create an object where some keys have the value "undefined", which causes the generated media-query to be invalid.
  // (min-width: 300px) and (max-width: undefined) is bad :(
  // (min-width: 300px) is good :)


  var mediaQuery = {};

  if (minWidth) {
    mediaQuery.minWidth = breakpoints[minWidth];
  }

  if (maxWidth) {
    mediaQuery.maxWidth = breakpoints[maxWidth] - 1;
  }

  return React.createElement(Media, _extends_1$4({}, rest, {
    query: _extends_1$4({}, mediaQuery, {}, query)
  }), children);
};

Responsive.propTypes = {
  /**
   * Set a min-width media query.
   */
  minWidth: PropTypes.oneOf(['sm', 'md', 'lg', 'xl']),

  /**
   * Set a max-width media query.
   */
  maxWidth: PropTypes.oneOf(['sm', 'md', 'lg', 'xl']),

  /**
   * An object containing any valid CSS media query characteristics. It will be converted to a CSS media query.
   * Use `query` if you need characteristics other than `minWidth` and `maxWidth`.
   *
   * Any `minWidth` or `maxWidth` values here will override the props by the same name.
   */
  query: PropTypes.object,

  /**
   * The content. Can be text, any HTML element, a function, or any component.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func])
};
Responsive.defaultProps = {
  minWidth: undefined,
  maxWidth: undefined,
  query: {},
  children: undefined
};

var thin$1 = {
  borderWidth: 1,
  borderStyle: 'solid'
};
var none$1 = {
  borderWidth: '0'
};
var rounded$1 = {
  borderRadius: '4px'
};
var circular$1 = {
  borderRadius: '50%'
};

var borders$1 = /*#__PURE__*/Object.freeze({
  thin: thin$1,
  none: none$1,
  rounded: rounded$1,
  circular: circular$1
});

/* eslint-disable import/prefer-default-export */
var noSpacing$1 = {
  padding: 0,
  margin: 0
};

var spacing$1 = /*#__PURE__*/Object.freeze({
  noSpacing: noSpacing$1
});

function createCommonjsModule$5(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1$5 = createCommonjsModule$5(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});
var font$1 = {
  fontFamily: fontTelus
};
var baseButton = _extends_1$5({
  margin: 0,
  padding: '0 2rem',
  cursor: 'pointer',
  background: 'none',
  transition: 'background 0.2s',
  display: 'flex',
  width: '100%',
  alignItems: 'center',
  justifyContent: 'center',
  textAlign: 'center',
  minHeight: '3.25rem'
}, media.from('md').css({
  display: 'inline-flex',
  width: 'auto',
  minWidth: '180px'
}), {
  // this is to fix the IE 11 bug to center text. For more info: https://github.com/philipwalton/flexbugs/issues/231
  '&:after': {
    content: "\"\"",
    minHeight: 'inherit',
    fontSize: 0
  }
});

/* eslint-disable import/prefer-default-export */
var base$2 = {
  '&': {
    paddingLeft: '3rem'
  },
  '& &': {
    marginTop: '1rem',
    marginBottom: '0.5rem'
  }
};
var nestedListSpacing$1 = _extends_1$5({}, base$2, {
  '& :last-child &': {
    marginBottom: 0
  }
});

/* eslint-disable import/prefer-default-export */

var noStyle$1 = _extends_1$5({}, noSpacing$1, {}, none$1, {}, font$1, {}, color, {
  appearance: 'none',
  background: 'none',
  boxShadow: 'none',
  cursor: 'pointer'
});

function createCommonjsModule$6(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1$6 = createCommonjsModule$6(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

var StyledDimpleDivider = styled.hr.withConfig({
  displayName: "DimpleDivider__StyledDimpleDivider",
  componentId: "quxnvh-0"
})(spacing$1.noSpacing, borders$1.none, {
  height: '32px',
  backgroundImage: 'radial-gradient(ellipse at top, rgba(150, 150, 150, 0.1) 0%, rgba(0, 0, 0, 0) 70%)'
});
/**
 * Separate modules.
 *
 * @version ./package.json
 */

var DimpleDivider = function DimpleDivider(_ref) {
  var rest = _extends_1$6({}, _ref);

  return React.createElement(StyledDimpleDivider, safeRest(rest));
};

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var taggedTemplateLiteral = _taggedTemplateLiteral;

function _templateObject8() {
  var data = taggedTemplateLiteral(["\n  display: flex;\n  align-items: center;\n  border: none;\n  background: none;\n  color: inherit;\n  text-decoration: inherit;\n  padding: 10px;\n  position: relative;\n  border: solid 2px transparent;\n  border-radius: 6px;\n\n  > h4 {\n    &:focus {\n      outline: none;\n    }\n  }\n  &:focus {\n    outline: none;\n    > h4 {\n      &:before {\n        content: '';\n        display: block;\n        position: absolute;\n        top: 0;\n        left: 0;\n        border: 2px solid #979797;\n        border-radius: 6px;\n        width: 100%;\n        height: 100%;\n      }\n    }\n  }\n  &:active {\n    outline: none;\n  }\n\n  ::-moz-focus-inner {\n    border: 0;\n  }\n\n  // not in an active tab\n  .react-tabs__tab:not([aria-selected='true']) & {\n    &:hover::after {\n      ", "\n    }\n\n    &:active::after {\n      ", "\n    }\n  }\n\n  // in an active tab\n  .react-tabs__tab[aria-selected='true'] & {\n    &::after {\n      ", "\n    }\n  }\n"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = taggedTemplateLiteral(["\n  background: ", ";\n  display: flex;\n  align-items: center;\n  ", ";\n\n  ", ";\n"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = taggedTemplateLiteral(["\n  position: absolute;\n  top: 0;\n  padding: 2px 0;\n  z-index: 10;\n  height: calc(100% - 8px);\n  display: flex;\n  align-items: stretch;\n  cursor: pointer;\n  &:focus {\n    outline: none;\n    div {\n      box-shadow: 0 0 0 2px #979797;\n      border-radius: 4px;\n      margin: 0 2px;\n    }\n  }\n  ", ";\n\n  ", ";\n"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = taggedTemplateLiteral(["\n  ", "\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = taggedTemplateLiteral(["\n  position: relative;\n  transition: 0.9s all ease;\n  padding-right: 24px;\n  transform: translate(", "px);\n  white-space: ", ";\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = taggedTemplateLiteral(["\n  display: flex;\n  position: relative;\n  overflow: hidden;\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = taggedTemplateLiteral(["\n  overflow-x: hidden;\n  position: relative;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = taggedTemplateLiteral(["\n  padding-top: 6px;\n  > div {\n    position: relative;\n  }\n  .react-tabs__tab-list {\n    padding: 2px 0 0 0;\n  }\n  .react-tabs__tab {\n    display: inline-flex;\n    cursor: pointer;\n    margin: 0 2px;\n    @media (min-width: 768px) {\n      margin: 0 6px;\n    }\n    min-height: 45px;\n    min-width: 44px;\n    text-align: center;\n    position: relative;\n\n    &:active,\n    &.react-tabs__tab--selected {\n      h4 {\n        text-shadow: 0px 0px 1px ", ";\n      }\n    }\n    &:focus {\n      outline: none;\n    }\n  }\n\n  .react-tabs__tab-panel {\n    display: none;\n\n    &.react-tabs__tab-panel--selected {\n      display: block;\n      margin-top: 0;\n    }\n  }\n\n  ", "\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
var TabsContainer = styled.div(_templateObject(), colorGreyShark$1, function (props) {
  return props.wrapLabels && css([".react-tabs__tab-list{display:flex;position:relative;}.react-tabs__tab{flex:0 0 auto;display:flex;white-space:initial;}"]);
});
var TabBorder = styled.div(_templateObject2());
var TabListOuterContainer = styled.div(_templateObject3());
var TabListContainer = styled.div(_templateObject4(), function (props) {
  return props.positionToMove;
}, function (props) {
  return props.wrapLabels ? 'normal' : 'nowrap';
});
var TabLabel = styled.h4(_templateObject5(), function (props) {
  return props.wrapLabel && css(["max-width:144px;display:flex;align-items:center;justify-content:center;"]);
});
var TabArrows = styled.div(_templateObject6(), function (props) {
  return props.direction === 'left' && css(["left:0;padding-right:7px;"]);
}, function (props) {
  return props.direction === 'right' && css(["right:0;padding-left:7px;"]);
});
var ArrowInner = styled.div(_templateObject7(), colorWhite, function (props) {
  return props.direction === 'left' && css(["border-right:1px solid ", ";"], colorGreyGainsboro);
}, function (props) {
  return props.direction === 'right' && css(["border-left:1px solid ", ";"], colorGreyGainsboro);
});

var pseudoBar = function pseudoBar(isSelected) {
  return "\n  content: '';\n  position: absolute;\n  left: 10px;\n  right: 10px;\n  bottom: 0;\n  border-top: solid 4px ".concat(isSelected ? colorGreyRaven : colorGreyGainsboro, ";\n");
};

var TabLabelContainer = styled.button(_templateObject8(), pseudoBar(false), pseudoBar(true), pseudoBar(true));

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

var JSONSafeStringify = function JSONSafeStringify(input) {
  var cache = [];
  var result = JSON.stringify(input, function (key, value) {
    if (_typeof_1(value) !== 'object' || value === null) {
      return value;
    }

    if (cache.includes(value)) {
      // Circular reference found, discard key
      return undefined;
    } // Store value in our collection


    cache.push(value);
    return value;
  });
  cache = null; // Enable garbage collection

  return result;
};

var hash = function hash(obj) {
  if (!obj) return 0;
  return typeof obj !== 'string' ? stringHash(JSONSafeStringify(obj)) : stringHash(obj);
};

/**
 * Page-able content panels for use with `Pagination`
 *
 * _This component can only be accessed as a name-spaced component: `Pagination.Panel` ._
 */

var Panel = function Panel(_ref) {
  var children = _ref.children,
      rest = objectWithoutProperties(_ref, ["children"]);

  return React.createElement("div", safeRest(rest), children);
};

Panel.propTypes = {
  /**
   * The content. Can be text, any HTML element, or any component.
   */
  children: PropTypes.node.isRequired
};

/**
 * @version ./package.json
 * @visibleName Tabs (beta)
 */

var Tabs = function Tabs(props) {
  // Constants
  var MARGIN_BUFFER = 24; // scroll arrow width

  var ENTER_KEY = 13;
  var SPACE_BAR_KEY = 32;
  var RIGHT_ARROW = 39;
  var LEFT_ARROW = 37;
  var TAB = 9;
  var currentFocus = useRef(0);
  var tabsRoot = useRef();
  var tabRef = useRef(null);
  var tabNavRef = useRef(null);
  var tabScrollIntervals = useRef([]);
  var tabScrollPosition = useRef(0); // 0,1,2... to keep track of the scroll page

  var tabArrowKeyIntervals = useRef([]); // list of tab indices where scrolling should happen

  var tabIsFocused = useRef(false); // checks if any of the tabs are in focus
  // helper to handle edge case for when only one tab is on the last scroll page
  // it prevents scrolling back to the left to accomodate accessibility needs

  var wasTabbedPastTabs = useRef(false);
  var finalScrollLeftTabPos = useRef(null); // keeps track of the left most visible tab on final scroll

  var _useState = useState(0),
      _useState2 = slicedToArray(_useState, 2),
      tabsTranslatePosition = _useState2[0],
      setTabsTranslatePosition = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = slicedToArray(_useState3, 2),
      resizeTriggered = _useState4[0],
      setResizeTriggered = _useState4[1];

  var _useState5 = useState(false),
      _useState6 = slicedToArray(_useState5, 2),
      isLeftArrowVisible = _useState6[0],
      setLeftArrowVisible = _useState6[1];

  var _useState7 = useState(false),
      _useState8 = slicedToArray(_useState7, 2),
      isRightArrowVisible = _useState8[0],
      setRightArrowVisible = _useState8[1];

  var _useState9 = useState(0),
      _useState10 = slicedToArray(_useState9, 2),
      current = _useState10[0],
      setCurrent = _useState10[1];

  var children = props.children,
      leftArrowLabel = props.leftArrowLabel,
      rightArrowLabel = props.rightArrowLabel,
      wrapLabels = props.wrapLabels,
      open = props.open,
      onOpen = props.onOpen,
      rest = objectWithoutProperties(props, ["children", "leftArrowLabel", "rightArrowLabel", "wrapLabels", "open", "onOpen"]);

  useEffect(function () {
    // if open is null or undefined it is uncontrolled
    // empty string may be a valid input to select no tabs (this case is required)
    if (open === null || open === undefined) return;
    if (!props.children.length) return;
    var tabIndex = props.children.findIndex(function (child) {
      return child.props.id === open;
    });

    if (tabIndex >= 0) {
      setCurrent(tabIndex);
      currentFocus.current = tabIndex;
      return;
    } // if tabIndex === null set to -1 to keep tabs contolled, but select no tab


    setCurrent(-1);
  }, [open]);

  var initializeScrollIncrements = function initializeScrollIncrements() {
    var tabContainerWidth = tabRef.current.parentElement.clientWidth;
    var tabContainerWidthWithBuffer = tabContainerWidth - MARGIN_BUFFER;

    if (!tabScrollIntervals.current.length) {
      var tabMargin = null;
      var totalTabWidth = 0;
      var tabsArray = tabRef.current && tabRef.current.children[0] && Array.from(tabRef.current.children[0].childNodes); // populates tabScrollIntervals and tabArrowKeyIntervals

      var currentTabsLength = 0;
      tabsArray.forEach(function (value, index) {
        if (!tabMargin) {
          tabMargin = value.offsetLeft * 2;
        }

        var increment = value.offsetWidth + tabMargin;
        totalTabWidth += increment;

        if (increment > tabContainerWidthWithBuffer && tabScrollIntervals.current.length === 0) {
          tabScrollIntervals.current.push(increment - MARGIN_BUFFER);
          tabArrowKeyIntervals.current.push(index);
          currentTabsLength = 0;
        } else if (increment > tabContainerWidthWithBuffer && tabScrollIntervals.current.length !== 0) {
          tabScrollIntervals.current.push(increment);
          tabArrowKeyIntervals.current.push(index);
          currentTabsLength = 0;
        } else if (currentTabsLength + increment > tabContainerWidthWithBuffer && tabScrollIntervals.current.length === 0) {
          tabScrollIntervals.current.push(currentTabsLength - MARGIN_BUFFER);
          tabArrowKeyIntervals.current.push(index);
          currentTabsLength = increment;
        } else if (currentTabsLength + increment > tabContainerWidthWithBuffer - MARGIN_BUFFER && tabScrollIntervals.current.length !== 0) {
          tabScrollIntervals.current.push(currentTabsLength);
          tabArrowKeyIntervals.current.push(index);
          currentTabsLength = increment;
        } else {
          currentTabsLength += increment;
        }
      }); // handles last scroll interval and makes sure the last tab is on the far right

      if (tabScrollIntervals.current.length > 0) {
        var tabSumBeforeFinalScroll = 0;

        if (tabArrowKeyIntervals.current.length > 1) {
          for (var i = 0; i < tabScrollIntervals.current.length - 1; i += 1) {
            tabSumBeforeFinalScroll += tabScrollIntervals.current[i];
          }

          tabScrollIntervals.current[tabScrollIntervals.current.length - 1] = totalTabWidth - tabContainerWidth - tabSumBeforeFinalScroll;
        } else {
          tabScrollIntervals.current[tabScrollIntervals.current.length - 1] = totalTabWidth - tabContainerWidth;
        } // grabs the final visible leftmost tab on the last scroll screen


        currentTabsLength = 0;

        for (var _i = tabsArray.length - 1; _i >= 0; _i -= 1) {
          var increment = tabsArray[_i].offsetWidth + tabMargin;

          if (currentTabsLength + increment > tabContainerWidth - MARGIN_BUFFER) {
            finalScrollLeftTabPos.current = _i;
            break;
          } else {
            currentTabsLength += increment;
          }
        }
      }
    }
  }; // activates whenever resize occurs
  // calculates incremental sum of tabScrollIntervals to adjust the tabs translation and autoscrolls
  // scrolling snaps to the closest value from the incremental sum of tabScrollIntervals and the previous translate position


  var setResizeScrollIntervals = function setResizeScrollIntervals() {
    tabScrollIntervals.current = [];
    tabArrowKeyIntervals.current = [];
    initializeScrollIncrements();
    currentFocus.current = 0;

    if (tabsTranslatePosition !== 0) {
      var tabSumArr = tabScrollIntervals.current.map(function (_, idx) {
        return tabScrollIntervals.current.slice(0, idx + 1).reduce(function (prev, curr) {
          return prev + curr;
        });
      });
      tabSumArr.unshift(0);
      var diffArr = tabSumArr.map(function (val) {
        return Math.abs(val - Math.abs(tabsTranslatePosition));
      });
      var minNumber = Math.min.apply(Math, toConsumableArray(diffArr));
      var index = diffArr.findIndex(function (val) {
        return val === minNumber;
      });

      if (-tabSumArr[index] === 0) {
        setTabsTranslatePosition(0);
      } else {
        setTabsTranslatePosition(-tabSumArr[index]);
      }

      tabScrollPosition.current = index;
    }
  };

  var handleBlur = function handleBlur() {
    // on blur in controlled mode, we set the index back to prop value
    if (open === null || open === undefined) return;
    var tabIndex = props.children.findIndex(function (child) {
      return child.props.id === open;
    });

    if (tabIndex !== current) {
      setCurrent(tabIndex);
      currentFocus.current = tabIndex;
    }
  };

  var scrollTabs = function scrollTabs(direction) {
    var currentPosition = tabsTranslatePosition;

    if (direction === 'right') {
      if (isRightArrowVisible && !isLeftArrowVisible) {
        currentPosition -= tabScrollIntervals.current[tabScrollPosition.current];
      } else {
        currentPosition -= tabScrollIntervals.current[tabScrollPosition.current];
      }

      tabScrollPosition.current += 1;
    }

    if (direction === 'left') {
      if (tabScrollPosition.current === 1) {
        currentPosition = 0;
      } else {
        currentPosition += tabScrollIntervals.current[tabScrollPosition.current - 1];
      }

      tabScrollPosition.current -= 1;
    }

    setTabsTranslatePosition(currentPosition);
  };

  var handleTabClick = function handleTabClick(e, index) {
    e.preventDefault(); // scrolls tabs to the right if tab clicked isn't fully visible

    if (tabArrowKeyIntervals.current[tabScrollPosition.current] === index) {
      scrollTabs('right');
    }

    if (tabScrollPosition.current === tabScrollIntervals.current.length && index === finalScrollLeftTabPos.current) {
      scrollTabs('left');
    }

    if (!open) {
      setCurrent(index); // set internally if not-controlled

      currentFocus.current = index;
      return;
    } // raise to controlling component to set on click if controlled


    onOpen(props.children[index].props.id);
  };

  var handleSelect = function handleSelect(index, previousIndex) {
    // this is for setting the focus in controlled mode
    // we need to temporarily set the index (f will undo)
    // only if both the newTab and previous are the same, was the tab actually clicked
    // and we can raise up the event.
    setCurrent(index);
    currentFocus.current = index;
    var newTab = props.children[index];
    var previousTab = props.children[previousIndex];

    if (newTab === previousTab) {
      // this is on a tab switch
      onOpen(newTab.props.id);
    }
  };

  var handleTabsKeyUp = function handleTabsKeyUp(e) {
    var numTabs = tabNavRef.current.node.parentNode.children.length;

    if ((e.keyCode === RIGHT_ARROW || !e.shiftKey && e.keyCode === TAB) && currentFocus.current < props.children.length - 1) {
      tabArrowKeyIntervals.current.forEach(function (num) {
        if (currentFocus.current + 1 === num && tabScrollPosition.current !== tabScrollIntervals.current.length) {
          scrollTabs('right');
        }
      });

      if (e.keyCode === RIGHT_ARROW || document.activeElement !== tabNavRef.current.node.parentNode.children[0].children[0]) {
        currentFocus.current += 1;
        tabNavRef.current.node.parentNode.children[currentFocus.current].children[0].focus();
      }
    }

    if ((e.keyCode === LEFT_ARROW || e.shiftKey && e.keyCode === TAB) && currentFocus.current > 0) {
      tabArrowKeyIntervals.current.slice().reverse().forEach(function (num) {
        if (e.keyCode === LEFT_ARROW && currentFocus.current === num || !wasTabbedPastTabs.current && e.shiftKey && e.keyCode === TAB && currentFocus.current === num) {
          scrollTabs('left');
        }
      });

      if (wasTabbedPastTabs.current) {
        wasTabbedPastTabs.current = !wasTabbedPastTabs.current;
      }

      if (e.keyCode === LEFT_ARROW || document.activeElement !== tabNavRef.current.node.parentNode.children[numTabs - 1].children[0]) {
        currentFocus.current -= 1;
        tabNavRef.current.node.parentNode.children[currentFocus.current].children[0].focus();
      }
    }

    if (e.keyCode === SPACE_BAR_KEY || e.keyCode === ENTER_KEY) {
      e.target.click();
    }

    return 0;
  }; // handles arrow visibility


  useEffect(function () {
    initializeScrollIncrements();

    if (tabScrollPosition.current === 0 && tabScrollIntervals.current.length > 0) {
      setRightArrowVisible(true);
      setLeftArrowVisible(false);
    } else if (tabScrollPosition.current === 0 && tabScrollIntervals.current.length === 0) {
      setRightArrowVisible(false);
      setLeftArrowVisible(false);
    } else if (tabScrollPosition.current === tabScrollIntervals.current.length && tabsTranslatePosition !== 0) {
      setRightArrowVisible(false);
      setLeftArrowVisible(true);
    } else {
      setRightArrowVisible(true);
      setLeftArrowVisible(true);
    }

    setResizeTriggered(false);
  }, [tabsTranslatePosition, resizeTriggered]);
  useEffect(function () {
    var handleResize = function handleResize() {
      currentFocus.current = 0;
      setResizeScrollIntervals();
      setResizeTriggered(true);
    };

    var handleGlobalTabUpEvent = function handleGlobalTabUpEvent(e) {
      var numTabs = tabNavRef.current.node.parentNode.children.length;
      tabIsFocused.current = false; // checks that a tab is focused if the tab key is pressed

      if (e.keyCode === TAB) {
        for (var i = 0; i < numTabs; i += 1) {
          if (document.activeElement === tabNavRef.current.node.parentNode.children[i].children[0]) {
            tabIsFocused.current = true;
          }
        }

        if (!tabIsFocused.current && currentFocus.current) {
          wasTabbedPastTabs.current = true;
        }
      }
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('keyup', handleGlobalTabUpEvent);
    return function () {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('keyup', handleGlobalTabUpEvent);
    };
  }, [resizeTriggered]);

  var handleArrowKeyUp = function handleArrowKeyUp(e, value) {
    if (e.keyCode === ENTER_KEY || e.keyCode === SPACE_BAR_KEY) {
      scrollTabs(value);
    }
  };

  var mapTabs = function mapTabs() {
    if (props.children.length > 0) {
      return props.children.map(function (tab, i) {
        return React.createElement(Tab, {
          id: tab.props.id,
          "aria-label": tab.props.heading,
          onBlur: handleBlur,
          tabIndex: "-1",
          key: hash(i),
          onClick: function onClick(e) {
            handleTabClick(e, i);
          },
          onKeyUp: function onKeyUp(e) {
            return handleTabsKeyUp(e);
          },
          ref: tabNavRef
        }, React.createElement(TabLabelContainer, null, React.createElement(TabLabel, {
          tabIndex: "-1",
          wrapLabel: wrapLabels
        }, tab.props.heading)));
      });
    }

    return '';
  };

  var mapTabContent = function mapTabContent() {
    if (props.children.length > 0) {
      return props.children.map(function (tab, i) {
        return React.createElement(TabPanel, {
          key: hash(i)
        }, React.createElement(FlexGrid, null, React.createElement(FlexGrid.Row, null, React.createElement(FlexGrid.Col, {
          xs: 12,
          tabIndex: "0"
        }, React.createElement(Panel, rest, children[current])))));
      });
    }

    return '';
  };

  return React.createElement(TabsContainer, _extends_1({}, safeRest(rest), {
    wrapLabels: wrapLabels,
    ref: tabsRoot
  }), React.createElement(FlexGrid, {
    gutter: false
  }, React.createElement(FlexGrid.Row, null, React.createElement(FlexGrid.Col, {
    xs: 12
  }, React.createElement(Tabs$1, {
    selectedIndex: open ? current : undefined,
    onSelect: onOpen ? handleSelect : undefined
  }, React.createElement(TabBorder, null, isLeftArrowVisible && React.createElement(TabArrows, {
    tabIndex: "0",
    direction: "left",
    "aria-label": leftArrowLabel,
    onKeyUp: function onKeyUp(e) {
      return handleArrowKeyUp(e, 'left');
    },
    onClick: function onClick() {
      return scrollTabs('left');
    }
  }, React.createElement(ArrowInner, {
    direction: "left"
  }, React.createElement(ChevronLeft, {
    variant: "basic"
  }))), React.createElement(TabListOuterContainer, null, React.createElement(TabListContainer, {
    ref: tabRef,
    positionToMove: tabsTranslatePosition,
    wrapLabels: wrapLabels
  }, React.createElement(TabList, {
    style: {
      width: '0'
    }
  }, mapTabs()))), isRightArrowVisible && React.createElement(TabArrows, {
    tabIndex: "0",
    direction: "right",
    "aria-label": rightArrowLabel,
    onKeyUp: function onKeyUp(e) {
      return handleArrowKeyUp(e, 'right');
    },
    onClick: function onClick() {
      return scrollTabs('right');
    }
  }, React.createElement(ArrowInner, {
    direction: "right"
  }, React.createElement(ChevronRight, {
    variant: "basic"
  })))), React.createElement(HairlineDivider, null), React.createElement(DimpleDivider, null), mapTabContent())))));
};

Tabs.propTypes = {
  /**
   * The tab panels. Must be at least one `<Tabs.Panel />`.
   */
  children: PropTypes.node.isRequired,
  leftArrowLabel: PropTypes.string,
  rightArrowLabel: PropTypes.string,

  /**
   * Allow tab labels to wrap to multiple lines
   */
  wrapLabels: PropTypes.bool,

  /**
   * Set the selected tab by id
   */
  open: PropTypes.string,

  /**
   * Event raised on tab click
   */
  onOpen: PropTypes.func
};
Tabs.defaultProps = {
  leftArrowLabel: 'Move menu to the left',
  rightArrowLabel: 'Move menu to the right',
  wrapLabels: false,
  open: null,
  onOpen: null
};
Tabs.Panel = Panel;

export default Tabs;
