import PropTypes, { arrayOf } from 'prop-types';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

var componentWithName = function componentWithName(passedName, checkDisplayName) {
  if (typeof passedName !== 'string') {
    throw new Error('passedName must be a string');
  }

  var checkProp = function checkProp(props, propName, componentName) {
    if (typeof props[propName] === 'undefined' || props[propName] === null) {
      return undefined;
    }

    if (Array.isArray(props[propName])) {
      // Iterates through every child and try to find the first element that does not match the passed name
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean
      return props[propName].map(function (_, index) {
        return checkProp(props[propName], index, componentName);
      }).find(Boolean);
    }

    var testNameInObject = function testNameInObject() {
      return _typeof_1(props[propName]) === 'object' && (!checkDisplayName && props[propName].type.name !== passedName || checkDisplayName && props[propName].type.displayName !== passedName);
    };

    var testNameInFunction = function testNameInFunction() {
      return typeof props[propName] === 'function' && (!checkDisplayName && props[propName].name !== passedName || checkDisplayName && props[propName].displayName !== passedName);
    };

    if (props[propName] && _typeof_1(props[propName]) !== 'object' && typeof props[propName] !== 'function' || testNameInObject() || testNameInFunction()) {
      return new Error("".concat(componentName, ": Component passed to `").concat(propName, "` prop should be ").concat(passedName));
    }

    return undefined;
  };

  var checkRequired = function checkRequired(props, propName, componentName) {
    if (props[propName] === undefined) {
      return new Error("The prop `".concat(propName, "` is marked as required in `").concat(componentName, "`, but its value is ").concat(props[propName], "."));
    }

    return undefined;
  };

  var createValidate = function createValidate(isRequired) {
    if (isRequired) {
      return function (props, propName, componentName) {
        var checkForError = checkProp(props, propName, componentName);

        if (checkForError) {
          return checkForError;
        }

        return checkRequired(props, propName, componentName);
      };
    }

    return checkProp;
  };

  var validate = createValidate();
  validate.isRequired = createValidate(true);
  return validate;
};

/**
 * Offset the specified number of columns within the 'sm' breakpoint range.
 *
 * @since 1.2.0
 */

function responsiveProps(type) {
  return PropTypes.oneOfType([type, PropTypes.shape({
    xs: type,
    sm: type,
    md: type,
    lg: type,
    xl: type
  })]);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

var createValidator = function createValidator(validators) {
  var validator = function validator(props, propName, componentName) {
    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }

    if (props[propName] === undefined) {
      return null;
    }

    var errors = validators.map(function (v) {
      return v.apply(void 0, [props, propName, componentName].concat(rest));
    }).filter(function (error) {
      return error;
    });

    if (errors.length >= validators.length) {
      return new Error("Invalid value supplied to ".concat(propName, " in ").concat(componentName, "."));
    }

    return null;
  };

  validator.isRequired = function (props, propName, componentName) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      rest[_key2 - 3] = arguments[_key2];
    }

    if (props[propName] === undefined) {
      return new Error("The prop `".concat(propName, "` is marked as required in `").concat(componentName, "`, but its value is ").concat(props[propName], "."));
    }

    var errors = validators.map(function (v) {
      return v.apply(void 0, [props, propName, componentName].concat(rest));
    }).filter(function (error) {
      return error;
    });

    if (errors.length === validators.length) {
      return new Error("Invalid value ".concat(errors, " supplied to required prop `").concat(propName, "` in `").concat(componentName, "`."));
    }

    return null;
  };

  return validator;
};

var or = function or(validators) {
  if (!Array.isArray(validators)) {
    throw new Error('2 or more validators are required to use or');
  }

  if (validators.length < 2) {
    throw new Error('2 or more validators are required to use or');
  }

  return createValidator([arrayOf(createValidator(validators))].concat(toConsumableArray(validators)));
};

var htmlElement = function htmlElement(element) {
  if (typeof element !== 'string') {
    throw new Error('element must be a string');
  }

  var checkProp = function checkProp(props, propName, componentName) {
    if (typeof props[propName] === 'undefined' || props[propName] === null) {
      return undefined;
    }

    if (Array.isArray(props[propName])) {
      // Iterates through every child and try to find the first element that does not match the passed name
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean
      return props[propName].map(function (_, index) {
        return checkProp(props[propName], index, componentName);
      }).find(Boolean);
    }

    if (_typeof_1(props[propName]) === 'object' && typeof props[propName].type === 'string') {
      if (props[propName].type === element) {
        return undefined;
      }

      return new Error("".concat(componentName, ": Expected `").concat(propName, "` to be an HTML `<").concat(element, ">` tag"));
    }

    return undefined;
  };

  var checkRequired = function checkRequired(props, propName, componentName) {
    if (props[propName] === undefined) {
      return new Error("The prop `".concat(propName, "` is marked as required in `").concat(componentName, "`, but its value is ").concat(props[propName], "."));
    }

    return undefined;
  };

  var createValidate = function createValidate(isRequired) {
    if (isRequired) {
      return function (props, propName, componentName) {
        var checkForError = checkProp(props, propName, componentName);

        if (checkForError) {
          return checkForError;
        }

        return checkRequired(props, propName, componentName);
      };
    }

    return checkProp;
  };

  var validate = createValidate();
  validate.isRequired = createValidate(true);
  return validate;
};

export { componentWithName, htmlElement, or, responsiveProps };
