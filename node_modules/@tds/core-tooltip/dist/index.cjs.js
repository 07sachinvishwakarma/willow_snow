'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));
var styled = _interopDefault(require('styled-components'));
var coreInteractiveIcon = require('@tds/core-interactive-icon');
var sharedStyles = require('@tds/shared-styles');
var utilHelpers = require('@tds/util-helpers');
var sharedHocs = require('@tds/shared-hocs');
var Box = _interopDefault(require('@tds/core-box'));
var coreResponsive = require('@tds/core-responsive');
var Text = _interopDefault(require('@tds/core-text'));
var A11yContent = _interopDefault(require('@tds/core-a11y-content'));
var utilPropTypes = require('@tds/util-prop-types');

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var assertThisInitialized = _assertThisInitialized;

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

var possibleConstructorReturn = _possibleConstructorReturn;

var getPrototypeOf = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
});

var setPrototypeOf = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
});

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

var inherits = _inherits;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

function find(t,n,r){if("function"==typeof Array.prototype.find)return t.find(n,r);r=r||this;var f=t.length;if("function"!=typeof n)throw new TypeError(n+" is not a function");for(var o=0;o<f;o++)if(n.call(r,t[o],o,t))return t[o]}

var sanitize = function sanitize(text) {
  return text.toString().toLowerCase().replace(/ /g, '-').replace(/[^a-zA-Z0-9-]/g, '');
};

var generateId = function generateId() {
  for (var _len = arguments.length, choices = new Array(_len), _key = 0; _key < _len; _key++) {
    choices[_key] = arguments[_key];
  }

  var id = sanitize(find(choices, function (choice) {
    return choice;
  }));
  return {
    identity: function identity() {
      return id;
    },
    postfix: function postfix(value) {
      return "".concat(id, "_").concat(sanitize(value));
    }
  };
};

// DO NOT MODIFY THIS FILE. IT IS COPIED DIRECTLY FROM AN NPM PACKAGE
// This was copied from the element-closest polyfill: github.com/jonathantneal/closest
// This version does not attempt to polyfill `Element` because window.Element is not available server side. This version
// is less invasive.
var matches = function matches(element, selector) {
  var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
  var index = 0;

  while (elements[index] && elements[index] !== element) {
    index += 1;
  }

  return Boolean(elements[index]);
};

var closest = function closest(element, selector) {
  var currentElement = element;

  while (currentElement && currentElement.nodeType === 1) {
    if (matches(currentElement, selector)) {
      return currentElement;
    }

    currentElement = currentElement.parentNode;
  }

  return null;
};

// colours
var colorWhite = '#fff'; // grey

var colorGreyShark = '#2a2c2e';

var dimensions = {
  bubbleTriggerSize: '24px',
  bubbleOffset: '7px',
  bubbleTriangleHeight: '10px',
  bubbleTriangleWidth: '7px',
  bubbleTrianglePosition: '12px' // bubbleTriangleWidth + 5

};
var BubbleStyle = styled(function (_ref) {
  var bubbleDimensions = _ref.bubbleDimensions,
      direction = _ref.direction,
      open = _ref.open,
      rest = objectWithoutProperties(_ref, ["bubbleDimensions", "direction", "open"]);

  return React__default.createElement(Box, rest);
}).attrs(function (_ref2) {
  var id = _ref2.id;
  return {
    'data-testid': 'bubble',
    id: id
  };
})(sharedStyles.borders.rounded, function (_ref3) {
  var bubbleDimensions = _ref3.bubbleDimensions,
      direction = _ref3.direction,
      open = _ref3.open;
  return _extends_1({}, {
    display: open ? undefined : 'none'
  }, {
    position: 'absolute',
    bottom: "calc(100% + ".concat(bubbleDimensions.bubbleTriangleHeight, ")"),
    backgroundColor: colorWhite,
    boxShadow: "0 0 2px 0 ".concat(colorGreyShark, ", 0 3px 2px 0 rgba(84, 89, 95, 0.25)")
  }, {
    right: direction === 'left' ? "-".concat(bubbleDimensions.bubbleOffset) : undefined
  }, {}, {
    left: direction === 'right' ? "calc(100% - ".concat(bubbleDimensions.bubbleTriggerSize, " - ").concat(bubbleDimensions.bubbleOffset, ")") : undefined
  }, {
    '&:before': _extends_1({
      content: "''",
      display: 'block',
      position: 'absolute',
      bottom: "-".concat(bubbleDimensions.bubbleTriangleWidth),
      borderWidth: bubbleDimensions.bubbleTriangleWidth,
      borderStyle: 'solid',
      borderColor: "transparent ".concat(colorWhite, " ").concat(colorWhite, " transparent"),
      backgroundColor: colorWhite,
      boxShadow: '2px 2px 3px 0 rgba(42, 42, 44, 0.4)',
      transform: 'rotate(45deg)'
    }, {
      right: direction === 'left' ? bubbleDimensions.bubbleTrianglePosition : undefined
    }, {}, {
      left: direction === 'right' ? bubbleDimensions.bubbleTrianglePosition : undefined
    })
  }, coreResponsive.media.until('sm').css({
    maxWidth: '80vw'
  }), {}, coreResponsive.media.from('sm').css({
    maxWidth: '50vw'
  }), {}, coreResponsive.media.from('md').css({
    maxWidth: '25vw'
  }));
});
var InnerBubbleStyle = styled.div.withConfig({
  displayName: "Bubble__InnerBubbleStyle",
  componentId: "sc-15jatun-0"
})(function (_ref4) {
  var bubbleWidth = _ref4.bubbleWidth;
  return _extends_1({}, bubbleWidth, {
    maxWidth: '100%'
  });
});

var Bubble = function Bubble(_ref5) {
  var id = _ref5.id,
      direction = _ref5.direction,
      open = _ref5.open,
      width = _ref5.width,
      children = _ref5.children;
  return React__default.createElement(BubbleStyle, {
    vertical: 2,
    horizontal: 3,
    bubbleDimensions: dimensions,
    direction: direction,
    open: open,
    role: "tooltip",
    "aria-live": "assertive",
    "aria-hidden": open ? 'false' : 'true',
    id: id
  }, React__default.createElement(InnerBubbleStyle, {
    bubbleWidth: width
  }, React__default.createElement(Text, {
    size: "small"
  }, children)));
};

Bubble.propTypes = {
  id: PropTypes.string.isRequired,
  direction: PropTypes.oneOf(['left', 'right']).isRequired,
  open: PropTypes.bool.isRequired,
  width: PropTypes.object.isRequired,
  children: PropTypes.node.isRequired
};

var StyledIconButton = styled.button.withConfig({
  displayName: "TooltipButton__StyledIconButton",
  componentId: "sc-1cfd6xf-0"
})(sharedStyles.buttons.noStyle);
var TooltipButton = React.forwardRef(function (_ref, ref) {
  var a11yText = _ref.a11yText,
      inverted = _ref.inverted,
      onClick = _ref.onClick,
      Icon = _ref.icon;
  return React__default.createElement(StyledIconButton, {
    onClick: onClick,
    ref: ref,
    type: "button"
  }, React__default.createElement(A11yContent, null, a11yText), React__default.createElement(Icon, {
    color: inverted ? 'white' : 'greyShark'
  }));
});
TooltipButton.displayName = 'TooltipButton';
TooltipButton.propTypes = {
  a11yText: PropTypes.string.isRequired,
  inverted: PropTypes.bool,
  onClick: PropTypes.func,
  icon: utilPropTypes.componentWithName('QuestionMarkCircle').isRequired
};
TooltipButton.defaultProps = {
  inverted: false,
  onClick: undefined
};

var copyDictionary = {
  en: {
    a11yTextStandalone: 'Reveal additional information.',
    a11yTextLinked: 'Reveal additional information for the field named "%{label}".'
  },
  fr: {
    a11yTextStandalone: 'Afficher des renseignements supplémentaires.',
    a11yTextLinked: 'Afficher des renseignements supplémentaires pour le champ nommé %{label}.'
  }
};

var StyledTooltip = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltip",
  componentId: "sc-2tc47i-0"
})(_extends_1({}, sharedStyles.iconWrapper.fixLineHeight, {
  position: 'relative',
  width: '1rem',
  height: '1.3rem'
}));
var TooltipContainer = styled.div.withConfig({
  displayName: "Tooltip__TooltipContainer",
  componentId: "sc-2tc47i-1"
})({
  position: 'absolute'
});
/**
 * Provide an explanation or instructions for a form field that most users do not need.
 *
 * @version ./package.json
 */

var T =
/*#__PURE__*/
function (_React$Component) {
  inherits(T, _React$Component);

  function T() {
    var _this;

    classCallCheck(this, T);

    _this = possibleConstructorReturn(this, getPrototypeOf(T).call(this));

    defineProperty(assertThisInitialized(_this), "state", {
      open: false,
      halfPageWidth: 0,
      tooltipPos: 0
    });

    defineProperty(assertThisInitialized(_this), "getTriggerA11yText", function (connectedFieldLabel, copy) {
      if (copy.a11yText) {
        return utilHelpers.getCopy(copyDictionary, copy).a11yText.replace('%{label}', connectedFieldLabel);
      }

      if (!connectedFieldLabel) {
        return utilHelpers.getCopy(copyDictionary, copy).a11yTextStandalone;
      }

      return utilHelpers.getCopy(copyDictionary, copy).a11yTextLinked.replace('%{label}', connectedFieldLabel);
    });

    defineProperty(assertThisInitialized(_this), "getIds", function (connectedFieldLabel) {
      var id = generateId(connectedFieldLabel, "standalone-tooltip ".concat(_this.uniqueId));
      return {
        bubbleId: id.postfix('tooltip'),
        triggerId: id.postfix('trigger')
      };
    });

    defineProperty(assertThisInitialized(_this), "setTooltipRef", function (element) {
      _this.refTooltip = element;
    });

    defineProperty(assertThisInitialized(_this), "toggleBubbleOnOutsideEvent", function (event) {
      var connectedFieldLabel = _this.props.connectedFieldLabel;

      var _this$getIds = _this.getIds(connectedFieldLabel),
          bubbleId = _this$getIds.bubbleId,
          triggerId = _this$getIds.triggerId;

      var inBubble = closest(event.target, "#".concat(bubbleId));
      var inTrigger = closest(event.target, "#".concat(triggerId));

      if (!inBubble && !inTrigger) {
        _this.toggleBubble();
      }
    });

    defineProperty(assertThisInitialized(_this), "toggleBubble", function () {
      _this.updatePageWidth();

      _this.setState(function (_ref) {
        var open = _ref.open;
        return {
          open: !open
        };
      });
    });

    defineProperty(assertThisInitialized(_this), "updatePageWidth", function () {
      if (_this.refTooltip) {
        _this.setState({
          halfPageWidth: window.innerWidth / 2,
          tooltipPos: _this.refTooltip.getBoundingClientRect().left
        });
      }
    });

    _this.refTooltip = null;
    return _this;
  }

  createClass(T, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updatePageWidth();
      this.uniqueId = this.props.tooltipId ? this.props.tooltipId : utilHelpers.uniqueId('tooltip');
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.state.open) {
        document.addEventListener('click', this.toggleBubbleOnOutsideEvent);
        document.addEventListener('keypress', this.toggleBubbleOnOutsideEvent);
        window.addEventListener('resize', this.updatePageWidth);
      } else {
        document.removeEventListener('click', this.toggleBubbleOnOutsideEvent);
        document.removeEventListener('keypress', this.toggleBubbleOnOutsideEvent);
        window.removeEventListener('resize', this.updatePageWidth);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener('click', this.toggleBubbleOnOutsideEvent);
      document.removeEventListener('keypress', this.toggleBubbleOnOutsideEvent);
      window.removeEventListener('resize', this.updatePageWidth);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          direction = _this$props.direction,
          connectedFieldLabel = _this$props.connectedFieldLabel,
          copy = _this$props.copy,
          children = _this$props.children,
          forwardedRef = _this$props.forwardedRef,
          rest = objectWithoutProperties(_this$props, ["direction", "connectedFieldLabel", "copy", "children", "forwardedRef"]);

      var _this$getIds2 = this.getIds(connectedFieldLabel),
          bubbleId = _this$getIds2.bubbleId,
          triggerId = _this$getIds2.triggerId;

      var trueDirection = null;

      if (direction === 'auto') {
        trueDirection = this.state.tooltipPos > this.state.halfPageWidth ? 'left' : 'right';
      } else {
        trueDirection = direction;
      }

      var bubbleWidth = trueDirection === 'left' ? this.state.tooltipPos : this.state.halfPageWidth * 2 - this.state.tooltipPos - 16;
      var width = {
        width: "calc(".concat(bubbleWidth, "px - 1rem - 0.5rem)")
      };
      return React__default.createElement(StyledTooltip, _extends_1({}, utilHelpers.safeRest(rest), {
        ref: forwardedRef || this.setTooltipRef
      }), React__default.createElement(TooltipContainer, {
        "data-testid": "tooltipContainer"
      }, React__default.createElement(Bubble, {
        id: bubbleId,
        direction: trueDirection,
        open: this.state.open,
        width: width
      }, children), React__default.createElement(TooltipButton, {
        icon: coreInteractiveIcon.QuestionMarkCircle,
        inverted: this.props.inverted,
        a11yText: this.getTriggerA11yText(this.props.connectedFieldLabel, this.props.copy),
        onClick: this.toggleBubble,
        id: triggerId,
        "aria-controls": bubbleId,
        "aria-haspopup": "true",
        "aria-expanded": this.state.open ? 'true' : 'false'
      })));
    }
  }]);

  return T;
}(React__default.Component);

var propTypes = {
  /**
   * Open the bubble to the left or right of the trigger.
   */
  direction: PropTypes.oneOf(['left', 'right', 'auto']),

  /**
   * The input field that using this tooltip must pass its label so that the tooltip trigger can connect itself. Do not
   * show this prop as it is not part of the public API. If this prop is not specified, the tooltip will generate
   * a generic ID, which could produce duplicate ids.
   *
   * @ignore
   */
  connectedFieldLabel: PropTypes.string,

  /**
   * Use the `copy` prop to either select provided English or French copy by passing 'en' or 'fr' respectively.
   *
   * To provide your own, pass a JSON object with the key, `a11yText`
   */
  copy: PropTypes.oneOfType([PropTypes.oneOf(['en', 'fr']), PropTypes.shape({
    a11yText: PropTypes.string
  })]).isRequired,

  /**
   * The message. Can be raw text or text components.
   */
  children: PropTypes.node.isRequired,

  /**
   * The tooltip id. Must be unique within the page.
   *
   * If a tooltip id is not provided, a unique tooltip id will be generated.
   */
  tooltipId: PropTypes.string,

  /* @ignore */
  forwardedRef: PropTypes.object,

  /**
   * If true, icon will render white.
   */
  inverted: PropTypes.bool
};
var defaultProps = {
  direction: 'auto',
  connectedFieldLabel: undefined,
  tooltipId: undefined,
  forwardedRef: undefined,
  inverted: false
};
var RefForwardedTooltip = sharedHocs.withForwardedRef(T);
var Tooltip = React__default.forwardRef(function (props, ref) {
  return React__default.createElement(RefForwardedTooltip, _extends_1({}, props, {
    ref: ref
  }));
});
Tooltip.propTypes = propTypes;
Tooltip.defaultProps = defaultProps;
T.propTypes = propTypes;
T.defaultProps = defaultProps;
Tooltip.displayName = 'Tooltip';

module.exports = Tooltip;
