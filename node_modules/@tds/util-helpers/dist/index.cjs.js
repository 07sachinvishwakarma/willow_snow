'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var coreResponsive = require('@tds/core-responsive');

var getCopy = function getCopy(dictionary, copy) {
  if (typeof copy === 'undefined' || copy === null) {
    return {};
  }

  if (typeof copy === 'string') {
    return dictionary[copy];
  }

  return copy;
};

// Taken from lodash: https://github.com/lodash/lodash/blob/master/uniqueId.js
var idCounter = 0;

var uniqueId = function uniqueId(prefix) {
  var id = ++idCounter; // eslint-disable-line no-plusplus

  return "".concat(prefix).concat(id);
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

var safeRest = (function (_ref) {
  var style = _ref.style,
      className = _ref.className,
      as = _ref.as,
      props = objectWithoutProperties(_ref, ["style", "className", "as"]);

  return props;
});

var BASE_FONT_SIZE = 16;

var pixelToRem = function pixelToRem(pixel) {
  return "".concat(pixel / BASE_FONT_SIZE, "rem");
};

var DependentIconSizeContext = react.createContext({});

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

var BREAKPOINTS = ['xs', 'sm', 'md', 'lg', 'xl'];
var MOBILE_BREAKPOINTS = ['xs', 'sm'];
var DESKTOP_BREAKPOINTS = ['md', 'lg', 'xl'];
var isMobileBreakpoint = function isMobileBreakpoint(breakpoint) {
  return MOBILE_BREAKPOINTS.indexOf(breakpoint) !== -1;
};
var isDesktopBreakpoint = function isDesktopBreakpoint(breakpoint) {
  return DESKTOP_BREAKPOINTS.indexOf(breakpoint) !== -1;
};

var isResponsiveProp = function isResponsiveProp(prop) {
  return prop && BREAKPOINTS.find(function (breakpoint) {
    return Object.prototype.hasOwnProperty.call(prop, breakpoint);
  });
};

var getResponsiveProps = function getResponsiveProps(props) {
  return Object.keys(props).filter(function (prop) {
    return isResponsiveProp(props[prop]);
  });
};

var getStaticProps = function getStaticProps(props) {
  return Object.keys(props).filter(function (prop) {
    return !isResponsiveProp(props[prop]);
  });
};

var sortBreakpointAsc = function sortBreakpointAsc(a, b) {
  if (BREAKPOINTS.indexOf(a.from) > BREAKPOINTS.indexOf(b.from)) {
    return 1;
  }

  if (BREAKPOINTS.indexOf(a.from) < BREAKPOINTS.indexOf(b.from)) {
    return -1;
  }

  return 0;
};

var collectBreakpoints = function collectBreakpoints(props) {
  return function (breakpoint) {
    var o = {
      from: breakpoint,
      until: undefined,
      props: _extends_1({}, getStaticProps(props).reduce(function (acc, staticProp) {
        if (typeof props[staticProp] !== 'undefined') {
          acc[staticProp] = props[staticProp];
        }

        return acc;
      }, {}), {}, getResponsiveProps(props).reduce(function (acc, responsiveProp) {
        if (typeof props[responsiveProp][breakpoint] !== 'undefined') {
          acc[responsiveProp] = props[responsiveProp][breakpoint];
        }

        return acc;
      }, {}))
    };
    return o;
  };
};

var inheritAndPopulateUntil = function inheritAndPopulateUntil(bp, index, src) {
  var breakpoint = bp;

  if (index !== 0) {
    breakpoint.props = _extends_1({}, src[index - 1].props, {}, bp.props);
  }

  if (index < src.length - 1) {
    breakpoint.until = src[index + 1].from;
  }

  return breakpoint;
};

var prepareArray = function prepareArray(props) {
  // gather all breakpoints
  var responsivePropNames = getResponsiveProps(props);
  var breakpoints = [];
  responsivePropNames.forEach(function (responsivePropName) {
    Object.keys(props[responsivePropName]).forEach(function (breakpoint) {
      if (breakpoints.indexOf(breakpoint) === -1) {
        breakpoints.push(breakpoint);
      }
    });
  }); // build object

  if (breakpoints.length === 0) {
    breakpoints.push('xs');
  }

  var preparedArray = breakpoints.map(collectBreakpoints(props)).sort(sortBreakpointAsc).map(inheritAndPopulateUntil);
  return preparedArray;
};
var generateStyles = function generateStyles(breakpoints, style) {
  var styles = breakpoints.reduce(function (acc, breakpoint) {
    var props = breakpoint.props;

    if (!(typeof breakpoint.from === 'undefined' && typeof breakpoint.until === 'undefined')) {
      var result = coreResponsive.media.from(breakpoint.from === 'xs' ? undefined : breakpoint.from).until(breakpoint.until === 'xl' ? undefined : breakpoint.until).css(typeof style === 'function' ? style(props, breakpoint.from, breakpoint.until) : style);
      return _extends_1({}, acc, {}, result);
    }

    return acc;
  }, {});
  return styles;
};

var handleBoundaryCrossing = function handleBoundaryCrossing(acc, curr) {
  if (isMobileBreakpoint(curr.from) && (curr.until !== 'md' && isDesktopBreakpoint(curr.until) || typeof curr.until === 'undefined')) {
    var props = Object.keys(curr.props).filter(function (prop) {
      return typeof curr.props[prop] === 'number' && curr.props[prop] > 3;
    });

    if (props.length !== 0) {
      var mobileBreakpoint = _extends_1({}, curr, {
        props: curr.props
      });

      var desktopBreakpoint = _extends_1({}, curr, {
        props: curr.props
      });

      mobileBreakpoint.until = 'md';
      desktopBreakpoint.from = 'md';
      return acc.concat([mobileBreakpoint, desktopBreakpoint]);
    }
  }

  return acc.concat([curr]);
};

var generateResponsiveStyles = function generateResponsiveStyles(props, styleFn) {
  var breakpoints = prepareArray(props);
  return generateStyles(breakpoints, styleFn);
};
var handleResponsiveStyles = function handleResponsiveStyles(props, styleFn) {
  var breakpoints = prepareArray(props).filter(function (bp) {
    return Object.keys(bp.props).length > 0;
  }).reduce(handleBoundaryCrossing, []);
  return generateStyles(breakpoints, styleFn);
};

/* eslint-disable import/prefer-default-export */

exports.DependentIconSizeContext = DependentIconSizeContext;
exports.generateResponsiveStyles = generateResponsiveStyles;
exports.generateStyles = generateStyles;
exports.getCopy = getCopy;
exports.handleResponsiveStyles = handleResponsiveStyles;
exports.pixelToRem = pixelToRem;
exports.prepareArray = prepareArray;
exports.safeRest = safeRest;
exports.uniqueId = uniqueId;
