import React from 'react';
import PropTypes from 'prop-types';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var browser = invariant;

var camel2hyphen = function (str) {
  return str
          .replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
          })
          .toLowerCase();
};

var camel2hyphen_1 = camel2hyphen;

var isDimension = function (feature) {
  var re = /[height|width]$/;
  return re.test(feature);
};

var obj2mq = function (obj) {
  var mq = '';
  var features = Object.keys(obj);
  features.forEach(function (feature, index) {
    var value = obj[feature];
    feature = camel2hyphen_1(feature);
    // Add px to dimension features
    if (isDimension(feature) && typeof value === 'number') {
      value = value + 'px';
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += 'not ' + feature;
    } else {
      mq += '(' + feature + ': ' + value + ')';
    }
    if (index < features.length-1) {
      mq += ' and ';
    }
  });
  return mq;
};

var json2mq = function (query) {
  var mq = '';
  if (typeof query === 'string') {
    return query;
  }
  // Handling array of media queries
  if (query instanceof Array) {
    query.forEach(function (q, index) {
      mq += obj2mq(q);
      if (index < query.length-1) {
        mq += ', ';
      }
    });
    return mq;
  }
  // Handling single media query
  return obj2mq(query);
};

var json2mq_1 = json2mq;

var MediaQueryListener =
/*#__PURE__*/
function () {
  function MediaQueryListener(targetWindow, query, listener) {
    var _this = this;

    this.nativeMediaQueryList = targetWindow.matchMedia(query);
    this.active = true; // Safari doesn't clear up listener with removeListener
    // when the listener is already waiting in the event queue.
    // Having an active flag to make sure the listener is not called
    // after we removeListener.

    this.cancellableListener = function () {
      _this.matches = _this.nativeMediaQueryList.matches;

      if (_this.active) {
        listener.apply(void 0, arguments);
      }
    };

    this.nativeMediaQueryList.addListener(this.cancellableListener);
    this.matches = this.nativeMediaQueryList.matches;
  }

  var _proto = MediaQueryListener.prototype;

  _proto.cancel = function cancel() {
    this.active = false;
    this.nativeMediaQueryList.removeListener(this.cancellableListener);
  };

  return MediaQueryListener;
}();

var queryType = PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.arrayOf(PropTypes.object.isRequired)]);
/**
 * Conditionally renders based on whether or not a media query matches.
 */

var Media =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Media, _React$Component);

  function Media(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "queries", []);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getMatches", function () {
      var result = _this.queries.reduce(function (acc, _ref) {
        var _extends2;

        var name = _ref.name,
            mqListener = _ref.mqListener;
        return _extends({}, acc, (_extends2 = {}, _extends2[name] = mqListener.matches, _extends2));
      }, {}); // return result;


      return unwrapSingleQuery(result);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateMatches", function () {
      var newMatches = _this.getMatches();

      _this.setState(function () {
        return {
          matches: newMatches
        };
      }, _this.onChange);
    });

    !(!(!props.query && !props.queries) || props.query && props.queries) ? process.env.NODE_ENV !== "production" ? browser(false, '<Media> must be supplied with either "query" or "queries"') : browser(false) : void 0;
    !(props.defaultMatches === undefined || !props.query || typeof props.defaultMatches === "boolean") ? process.env.NODE_ENV !== "production" ? browser(false, "<Media> when query is set, defaultMatches must be a boolean, received " + typeof props.defaultMatches) : browser(false) : void 0;
    !(props.defaultMatches === undefined || !props.queries || typeof props.defaultMatches === "object") ? process.env.NODE_ENV !== "production" ? browser(false, "<Media> when queries is set, defaultMatches must be a object of booleans, received " + typeof props.defaultMatches) : browser(false) : void 0;

    if (typeof window !== "object") {
      // In case we're rendering on the server, apply the default matches
      var matches;

      if (props.defaultMatches !== undefined) {
        matches = props.defaultMatches;
      } else if (props.query) {
        matches = true;
      }
      /* if (props.queries) */
      else {
          matches = Object.keys(_this.props.queries).reduce(function (acc, key) {
            var _extends3;

            return _extends({}, acc, (_extends3 = {}, _extends3[key] = true, _extends3));
          }, {});
        }

      _this.state = {
        matches: matches
      };
      return _assertThisInitialized(_this);
    }

    _this.initialize(); // Instead of calling this.updateMatches, we manually set the initial state to prevent
    // calling setState, which could trigger an unnecessary second render


    _this.state = {
      matches: _this.props.defaultMatches !== undefined ? _this.props.defaultMatches : _this.getMatches()
    };

    _this.onChange();

    return _this;
  }

  var _proto = Media.prototype;

  _proto.initialize = function initialize() {
    var _this2 = this;

    var targetWindow = this.props.targetWindow || window;
    !(typeof targetWindow.matchMedia === "function") ? process.env.NODE_ENV !== "production" ? browser(false, "<Media targetWindow> does not support `matchMedia`.") : browser(false) : void 0;
    var queries = this.props.queries || wrapInQueryObject(this.props.query);
    this.queries = Object.keys(queries).map(function (name) {
      var query = queries[name];
      var qs = typeof query !== "string" ? json2mq_1(query) : query;
      var mqListener = new MediaQueryListener(targetWindow, qs, _this2.updateMatches);
      return {
        name: name,
        mqListener: mqListener
      };
    });
  };

  _proto.componentDidMount = function componentDidMount() {
    this.initialize(); // If props.defaultMatches has been set, ensure we trigger a two-pass render.
    // This is useful for SSR with mismatching defaultMatches vs actual matches from window.matchMedia
    // Details: https://github.com/ReactTraining/react-media/issues/81

    if (this.props.defaultMatches !== undefined) {
      this.updateMatches();
    }
  };

  _proto.onChange = function onChange() {
    var onChange = this.props.onChange;

    if (onChange) {
      onChange(this.state.matches);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.queries.forEach(function (_ref2) {
      var mqListener = _ref2.mqListener;
      return mqListener.cancel();
    });
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        render = _this$props.render;
    var matches = this.state.matches;
    var isAnyMatches = typeof matches === "object" ? Object.keys(matches).some(function (key) {
      return matches[key];
    }) : matches;
    return render ? isAnyMatches ? render(matches) : null : children ? typeof children === "function" ? children(matches) : !Array.isArray(children) || children.length // Preact defaults to empty children array
    ? isAnyMatches ? // We have to check whether child is a composite component or not to decide should we
    // provide `matches` as a prop or not
    React.Children.only(children) && typeof React.Children.only(children).type === "string" ? React.Children.only(children) : React.cloneElement(React.Children.only(children), {
      matches: matches
    }) : null : null : null;
  };

  return Media;
}(React.Component);
/**
 * Wraps a single query in an object. This is used to provide backward compatibility with
 * the old `query` prop (as opposed to `queries`). If only a single query is passed, the object
 * will be unpacked down the line, but this allows our internals to assume an object of queries
 * at all times.
 */


_defineProperty(Media, "propTypes", {
  defaultMatches: PropTypes.oneOfType([PropTypes.bool, PropTypes.objectOf(PropTypes.bool)]),
  query: queryType,
  queries: PropTypes.objectOf(queryType),
  render: PropTypes.func,
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  targetWindow: PropTypes.object,
  onChange: PropTypes.func
});

function wrapInQueryObject(query) {
  return {
    __DEFAULT__: query
  };
}
/**
 * Unwraps an object of queries, if it was originally passed as a single query.
 */


function unwrapSingleQuery(queryObject) {
  var queryNames = Object.keys(queryObject);

  if (queryNames.length === 1 && queryNames[0] === "__DEFAULT__") {
    return queryObject.__DEFAULT__;
  }

  return queryObject;
}

/* eslint-disable import/prefer-default-export */
var warn = function warn(componentName, message) {
  if (process.env.NODE_ENV === 'production') {
    return;
  }

  console.warn("[TDS] ".concat(componentName, ": ").concat(message)); // eslint-disable-line no-console
};

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty$1;

var breakpoints = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
var media = {
  query: {},
  from: function from(breakpoint) {
    if (breakpoint !== 'xs') {
      this.query.minWidth = breakpoint;
    }

    return this;
  },
  until: function until(breakpoint) {
    this.query.maxWidth = breakpoint;
    return this;
  },
  and: function and(custom) {
    this.query.and = custom;
    return this;
  },
  css: function css(style) {
    var _this$query = this.query,
        minWidth = _this$query.minWidth,
        maxWidth = _this$query.maxWidth,
        and = _this$query.and;
    var min = minWidth ? "(min-width: ".concat(breakpoints[minWidth], "px)") : undefined;
    var max = maxWidth ? "(max-width: ".concat(breakpoints[maxWidth] - 1, "px)") : undefined;

    if (typeof min !== 'undefined' || typeof max !== 'undefined' || typeof and !== 'undefined') {
      var mediaQuery = "@media ".concat([min, max, and].filter(function (a) {
        return a;
      }).join(' and '));
      this.query = {};
      return defineProperty({}, mediaQuery, _extends_1({}, typeof style === 'function' ? style() : style));
    }

    return typeof style === 'function' ? style() : style;
  }
};

/**
 * Respond to device features, most commonly the browser viewport size.
 *
 * @version ./package.json
 */

var Responsive = function Responsive(_ref) {
  var minWidth = _ref.minWidth,
      maxWidth = _ref.maxWidth,
      query = _ref.query,
      children = _ref.children,
      rest = objectWithoutProperties(_ref, ["minWidth", "maxWidth", "query", "children"]);

  if (!minWidth && !maxWidth) {
    warn('Responsive', 'Responsive needs a minWidth or maxWith prop');
  } // Do it this way to not create an object where some keys have the value "undefined", which causes the generated media-query to be invalid.
  // (min-width: 300px) and (max-width: undefined) is bad :(
  // (min-width: 300px) is good :)


  var mediaQuery = {};

  if (minWidth) {
    mediaQuery.minWidth = breakpoints[minWidth];
  }

  if (maxWidth) {
    mediaQuery.maxWidth = breakpoints[maxWidth] - 1;
  }

  return React.createElement(Media, _extends_1({}, rest, {
    query: _extends_1({}, mediaQuery, {}, query)
  }), children);
};

Responsive.propTypes = {
  /**
   * Set a min-width media query.
   */
  minWidth: PropTypes.oneOf(['sm', 'md', 'lg', 'xl']),

  /**
   * Set a max-width media query.
   */
  maxWidth: PropTypes.oneOf(['sm', 'md', 'lg', 'xl']),

  /**
   * An object containing any valid CSS media query characteristics. It will be converted to a CSS media query.
   * Use `query` if you need characteristics other than `minWidth` and `maxWidth`.
   *
   * Any `minWidth` or `maxWidth` values here will override the props by the same name.
   */
  query: PropTypes.object,

  /**
   * The content. Can be text, any HTML element, a function, or any component.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func])
};
Responsive.defaultProps = {
  minWidth: undefined,
  maxWidth: undefined,
  query: {},
  children: undefined
};

export default Responsive;
export { breakpoints, media };
