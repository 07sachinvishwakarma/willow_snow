import React, { useState } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { componentWithName } from '@tds/util-prop-types';
import InputFeedback from '@tds/core-input-feedback';
import Box from '@tds/core-box';
import Text from '@tds/core-text';
import Paragraph from '@tds/core-paragraph';
import { borders, forms, position } from '@tds/shared-styles';
import { colorGreyShuttle, colorWhite, colorGreyAthens, colorPrimary, colorCardinal } from '@tds/core-colours';
import { medium, mediumFont, color } from '@tds/shared-typography';
import { FeedbackIcon } from '@tds/core-input';
import { safeRest } from '@tds/util-helpers';

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

function find(t,n,r){if("function"==typeof Array.prototype.find)return t.find(n,r);r=r||this;var f=t.length;if("function"!=typeof n)throw new TypeError(n+" is not a function");for(var o=0;o<f;o++)if(n.call(r,t[o],o,t))return t[o]}

var sanitize = function sanitize(text) {
  return text.toString().toLowerCase().replace(/ /g, '-').replace(/[^a-zA-Z0-9-]/g, '');
};

var generateId = function generateId() {
  for (var _len = arguments.length, choices = new Array(_len), _key = 0; _key < _len; _key++) {
    choices[_key] = arguments[_key];
  }

  var id = sanitize(find(choices, function (choice) {
    return choice;
  }));
  return {
    identity: function identity() {
      return id;
    },
    postfix: function postfix(value) {
      return "".concat(id, "_").concat(sanitize(value));
    }
  };
};

var widthLimit = {
  maxWidth: '100%',
  minWidth: '100%',
  minHeight: '208px',
  position: 'relative'
};
var PreventWidthResize = styled.div.withConfig({
  displayName: "TextArea__PreventWidthResize",
  componentId: "fii7gw-0"
})(_extends_1({}, widthLimit));
var StyledLabelContainer = styled(Box)({
  alignItems: 'center'
});
var StyledTextArea = styled.textarea.withConfig({
  displayName: "TextArea__StyledTextArea",
  componentId: "fii7gw-1"
})(widthLimit, {
  width: '100%',
  margin: 0,
  outline: 0,
  textOverflow: 'ellipsis',
  borderColor: colorGreyShuttle,
  '-ms-overflow-style': '-ms-autohiding-scrollbar',
  '&::placeholder': {
    font: 'inherit',
    letterSpacing: 'inherit',
    lineHeight: 'inherit',
    color: colorGreyShuttle
  }
}, borders.thin, borders.rounded, forms.font, medium, mediumFont, color, function (_ref) {
  var withFeedbackIcon = _ref.withFeedbackIcon;
  return {
    '&::-webkit-inner-spin-button, &::-webkit-outer-spin-button': {
      appearance: 'none',
      margin: 0
    },
    '-moz-appearance': 'textfield',
    padding: withFeedbackIcon ? '0.5rem 3rem 0.5rem 1rem' : '0.5rem 1rem'
  };
}, {
  '&:focus': {
    borderColor: 'transparent',
    boxShadow: "0 0 4px 1px ".concat(colorGreyShuttle),
    backgroundColor: colorWhite
  }
}, function (_ref2) {
  var feedback = _ref2.feedback;
  var borderColor;

  if (feedback === 'success') {
    borderColor = colorPrimary;
  } else if (feedback === 'error') {
    borderColor = colorCardinal;
  }

  return {
    '&:not(:focus)': {
      borderColor: borderColor
    }
  };
}, function (_ref3) {
  var disabled = _ref3.disabled;

  if (disabled) {
    return {
      backgroundColor: colorGreyAthens,
      borderColor: 'transparent',
      '&:not(:focus)': {
        borderColor: 'transparent'
      }
    };
  }

  return {};
});
var StyledFeedbackIcon = styled.div.withConfig({
  displayName: "TextArea__StyledFeedbackIcon",
  componentId: "fii7gw-2"
})(position.absolute, {
  right: '1rem',
  top: '0.5rem',
  overflow: 'visible' // Prevents icon cut-off on Mobile Safari

});

var showFeedbackIcon = function showFeedbackIcon(feedback) {
  return feedback === 'error' || feedback === 'success';
};

var renderHint = function renderHint(hint, Component, id) {
  return React.createElement(Component, {
    id: id,
    size: "small"
  }, hint);
};

var renderError = function renderError(error, errorId) {
  return React.createElement(InputFeedback, {
    id: errorId,
    feedback: "error"
  }, React.createElement(Paragraph, {
    size: "small"
  }, error));
};

var renderLabel = function renderLabel(id, label, hint, hintId, tooltip) {
  return React.createElement(Box, {
    inline: true,
    between: 2
  }, React.createElement("label", {
    htmlFor: id || generateId(label).identity()
  }, React.createElement(StyledLabelContainer, {
    inline: true,
    tag: "span",
    between: 2
  }, React.createElement(Text, {
    size: "medium",
    bold: true
  }, label), hint && renderHint(hint, Text, hintId))), tooltip && React.cloneElement(tooltip, {
    connectedFieldLabel: label
  }));
};

var renderHelper = function renderHelper(helper, helperId, feedback, value) {
  if (typeof helper === 'function') {
    return React.createElement("div", {
      id: helperId
    }, React.createElement(Text, {
      size: "small"
    }, helper(feedback, value)));
  }

  return React.createElement(InputFeedback, {
    id: helperId,
    feedback: feedback
  }, React.createElement(Text, {
    size: "small"
  }, helper));
};
/**
 * @version ./package.json
 */


var TextArea = React.forwardRef(function (_ref4, ref) {
  var id = _ref4.id,
      value = _ref4.value,
      label = _ref4.label,
      hint = _ref4.hint,
      feedback = _ref4.feedback,
      error = _ref4.error,
      helper = _ref4.helper,
      tooltip = _ref4.tooltip,
      rest = objectWithoutProperties(_ref4, ["id", "value", "label", "hint", "feedback", "error", "helper", "tooltip"]);

  var _useState = useState(false),
      _useState2 = slicedToArray(_useState, 2),
      isFocused = _useState2[0],
      setIsFocused = _useState2[1];

  var fieldId = generateId(id, rest.name, label);
  var errorId = error && feedback === 'error' && fieldId.postfix('error-message');
  var helperId = helper && fieldId.postfix('helper');
  var hintId = hint && fieldId.postfix('hint') || undefined;

  var handleFocus = function handleFocus(e) {
    setIsFocused(true);

    if (rest.onFocus) {
      rest.onFocus(e);
    }
  };

  var handleBlur = function handleBlur(e) {
    setIsFocused(false);

    if (rest.onBlur) {
      rest.onBlur(e);
    }
  };

  return React.createElement(Box, {
    between: 2
  }, renderLabel(fieldId.identity(), label, hint, hintId, tooltip), helper && renderHelper(helper, helperId, feedback, value), error && feedback === 'error' && renderError(error, errorId), React.createElement(PreventWidthResize, null, React.createElement(StyledTextArea, _extends_1({}, safeRest(rest), {
    ref: ref,
    id: fieldId.identity(),
    value: value,
    feedback: feedback,
    "aria-invalid": feedback === 'error',
    "aria-describedby": errorId || hintId || helperId || undefined,
    onFocus: handleFocus,
    onBlur: handleBlur,
    withFeedbackIcon: showFeedbackIcon
  })), !rest.disabled && React.createElement(StyledFeedbackIcon, null, React.createElement(FeedbackIcon, {
    showIcon: showFeedbackIcon(feedback) && !isFocused,
    feedback: feedback
  }))));
});
TextArea.displayName = 'TextArea';
TextArea.propTypes = {
  /**
   * The id. If no `id` is provided, a default `id` will be generated using the `label`. "This is a label" will become "this-is-a-label". A passed in `id` will appear as entered with no additional formatting.
   */
  id: PropTypes.string,

  /**
   * The label.
   */
  label: PropTypes.string.isRequired,

  /**
   * Clarify the expected input.
   */
  hint: PropTypes.string,

  /**
   * Use `value` for controlled TextArea. For uncontrolled TextArea, use React's built-in `defaultValue` prop.
   * See examples below for more details.
   */
  value: PropTypes.string,

  /**
   * A feedback state.
   */
  feedback: PropTypes.oneOf(['success', 'error']),

  /**
   * An error message. Either an error or a helper should be used, not both.
   */
  error: PropTypes.node,

  /**
   * A detailed explanation of the input expected by a form field. Can be text,
   * other components, or HTML elements.
   *
   * If a function is provided, it must return an `InputFeedback`. The function will be
   * invoked with the following arguments.
   *
   * @param {String} feedback The input's current feedback state.
   * @param {String} value The input's current value.
   */
  helper: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),

  /**
   * A `Tooltip`
   */
  tooltip: componentWithName('Tooltip', true)
};
TextArea.defaultProps = {
  id: undefined,
  hint: undefined,
  value: undefined,
  feedback: undefined,
  error: undefined,
  tooltip: undefined,
  helper: undefined
};

export default TextArea;
